<html><body bgcolor="#ffffff" text="#000000"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Treeland has N cities, numbered 0 through N-1.
There are N-1 undirected roads, each connecting a pair of cities.
The roads form a tree.
(I.e., each pair of cities is connected via some sequence of roads.)
<br></br>
<br></br>
You are given a string <b>linked</b> with N elements, each consisting of N characters.
There is a road between city i and city j if and only if <b>linked</b>[i][j] is 'Y'.
In all other cases <b>linked</b>[i][j] is 'N'.
<br></br>
<br></br>
The inhabitants of Treeland want to create the Treeland Positioning System (TPS).
TPS will be a system that will help people determine which city they are in.
The system will consist of K labeled beacons.
Each beacon will be located in one of the cities.
When a person turns on their TPS receiver, it will determine its distance to each of the beacons.
(The distance is measured as the number of roads the person would have to use in order to reach the beacon.)
<br></br>
<br></br>
Obviously, TPS will only be usable if different cities correspond to different readings on the receiver.
In other words, the number K and the placement of beacons must be such that there are no two cities where the receiver will report the same sequence of values.
(Note that the beacons can be distinguished. See Example 1.)
<br></br>
<br></br>
Return the minimal possible value of K.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>TPS</td></tr><tr><td>Method:</td><td>minimalBeacons</td></tr><tr><td>Parameters:</td><td>vector &lt;string&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int minimalBeacons(vector &lt;string&gt; linked)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>64</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td>N will be between 1 and 50, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>linked</b> will contain N elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>linked</b> will contain N characters.</td></tr><tr><td align="center" valign="top">-</td><td>Each character of each element of <b>linked</b> will be either 'Y' or 'N'.</td></tr><tr><td align="center" valign="top">-</td><td>For each i and j, if <b>linked</b>[i][j] is 'Y' then <b>linked</b>[j][i] is 'Y'.</td></tr><tr><td align="center" valign="top">-</td><td>For each i, <b>linked</b>[i][i] will be 'N'.</td></tr><tr><td align="center" valign="top">-</td><td>The graph described by <b>linked</b> will be a tree with N nodes.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYNN&quot;,
 &quot;YNYN&quot;,
 &quot;NYNY&quot;,
 &quot;NNYN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">There are 4 cities and 3 roads: 0-1-2-3.
One possible solution is to put a beacon in city 0. Then city i will have distance i from that beacon, and they are distinguishable.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYYY&quot;,
 &quot;YNNN&quot;,
 &quot;YNNN&quot;,
 &quot;YNNN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">There are also 4 cities. The road network looks as follows:
<pre>
1 - 0 - 2
    |
    3
</pre>
1 beacon is not enough, for example:
<ul>
<li>If it is located in city 0, then cities 1,2 and 3 all have distance 1 from that beacon, they are not distinguishable.</li>
<li>If it is located in city 1, then cities 2, 3 all have distance 2 from that beacon, they are not distinguishable.</li>
</ul>
2 beacons are enough. For example, we can place them into cities 1 and 2. Then:
<ul>
<li>If we are in city 0 the receiver will show the distances 1, 1.</li>
<li>If we are in city 1 the receiver will show the distances 0, 2.</li>
<li>If we are in city 2 the receiver will show the distances 2, 0.</li>
<li>If we are in city 3 the receiver will show the distances 2, 2.</li>
</ul>
In each city the receiver shows a different sequence of distances.
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NNYNNNNNNN&quot;,
 &quot;NNNNNYNNNN&quot;,
 &quot;YNNYNNYNNN&quot;,
 &quot;NNYNYNNYNN&quot;,
 &quot;NNNYNYNNYN&quot;,
 &quot;NYNNYNNNNY&quot;,
 &quot;NNYNNNNNNN&quot;,
 &quot;NNNYNNNNNN&quot;,
 &quot;NNNNYNNNNN&quot;,
 &quot;NNNNNYNNNN&quot;}
</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">The graph looks as follows:
<pre>
0           1
|           |
2 - 3 - 4 - 5
|   |   |   |
6   7   8   9
</pre>
One optimal solution is to put beacons into cities 0 and 1.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYNYNNYNN&quot;,
 &quot;YNYNYNNYN&quot;,
 &quot;NYNNNYNNY&quot;,
 &quot;YNNNNNNNN&quot;,
 &quot;NYNNNNNNN&quot;,
 &quot;NNYNNNNNN&quot;,
 &quot;YNNNNNNNN&quot;,
 &quot;NYNNNNNNN&quot;,
 &quot;NNYNNNNNN&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 3</pre></td></tr><tr><td><table><tr><td colspan="2">The graph looks as follows:
<pre>
3   4   5
|   |   |
0 - 1 - 2
|   |   |
6   7   8
</pre>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;NYYYYYYYYY&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;,
 &quot;YNNNNNNNNN&quot;}
</pre></td></tr></table></td></tr><tr><td><pre>Returns: 8</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;N&quot;}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2">We don't need any beacon at all, since there is only 1 city.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
